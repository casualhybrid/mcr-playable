using FSM;
using UnityEngine;
using DG.Tweening;
using System.Linq;

[CreateAssetMenu(fileName = "PlayerBuildingRunState", menuName = "ScriptableObjects/PlayerBuildingRunState")]
public class PlayerBuildingRunState : StateBase
{
    [SerializeField] private PlayerContainedData PlayerContainedData;
    [SerializeField] private PlayerSharedData PlayerSharedData;
    [SerializeField] private GameEvent playerStoppedVerticalMotionBuilding;
    [SerializeField] private GameEvent playerStartedBuildingClimb;

    private RaycastHit wallBuildinghit;
    private int counter;
    private bool followingPath;

    private void OnEnable()
    {
        UnityEngine.SceneManagement.SceneManager.activeSceneChanged += (scene, mode) => { ResetVariable(); };
    }

    private void ResetVariable()
    {
        UnSubsribeInputEvents();
        counter = 0;
    }

    //subscribing all events that can occur during this state
    private void SubsribeInputEvents()
    {
        PlayerContainedData.InputChannel.SwipeRightOccured.AddListener(SwipedRight);
        PlayerContainedData.InputChannel.SwipeLeftOccured.AddListener(SwipedLeft);
    }

    /// <summary>
    ///unsubscribing all events that can occur during this state
    /// </summary>
    public void UnSubsribeInputEvents()
    {
        PlayerContainedData.InputChannel.SwipeRightOccured.RemoveListener(SwipedRight);
        PlayerContainedData.InputChannel.SwipeLeftOccured.RemoveListener(SwipedLeft);
    }

    public override void OnEnter()
    {
        base.OnEnter();
        counter = 0;

        PlayerSharedData.WallClimbDoing = true;
        PlayerSharedData.WallRunBuilding = true;
        followingPath = false;

        FollowThePath();

        UnSubsribeInputEvents();
        SubsribeInputEvents();
    }

    //this is called when jump restarts

    //onexit will be called once when state exits
    public override void OnExit()
    {
        base.OnExit();
        PlayerSharedData.BuildingRunPath.Clear();

        UnSubsribeInputEvents();
    }

    //onlogic basically works as update , all work related to update will be done in this method
    public override void OnLogic()
    {
        base.OnLogic();
    }

    private void FollowThePath()
    {
        followingPath = true;
        playerStartedBuildingClimb.RaiseEvent();
        Vector3[] path = new Vector3[PlayerSharedData.BuildingRunPath.Count];

        for (int i = 0; i < PlayerSharedData.BuildingRunPath.Count; i++)
        {
            path[i] = PlayerSharedData.BuildingRunPath[i].position;
            Debug.Log("Adding " + path[i]);
        }

        PlayerSharedData.PlayerRigidBody.DOPath(path, 3f, PathType.Linear, PathMode.Full3D).SetLookAt(0f).SetUpdate(UpdateType.Fixed).OnComplete(()=> { followingPath = false; });
      
        
    }

    //onfixlogic basically works as fixupdate , all work related to fixupdate will be done in this method
    public override void OnFixedLogic()
    {
        base.OnFixedLogic();


        if (!followingPath)
        PlayerContainedData.PlayerBasicMovementShared.movement();
        
        
        //if (counter < PlayerSharedData.BuildingRunPath.Count)
        //{
        //    if (PlayerSharedData.PlayerTransform.position.z >= PlayerSharedData.BuildingRunPath[counter].transform.position.z && !PlayerSharedData.RotateOnbuilding)
        //    {
        //        playerStartedBuildingClimb.RaiseEvent();
        //        PlayerSharedData.PlayerTransform.rotation = PlayerSharedData.BuildingRunPath[counter].transform.rotation;
        //        counter++;
        //    }
        //}
        if (PlayerSharedData.RotateOnbuilding)
            BuildingRotation();
    }

    private void SwipedRight()
    {
        PlayerContainedData.PlayerBasicMovementShared.change_lane(1);
    }

    private void SwipedLeft()
    {
        PlayerContainedData.PlayerBasicMovementShared.change_lane(-1);
    }

    public override void OnTriggerEnter(Collider other)
    {
    }

    public override void OnTriggerExit(Collider other)
    {
        if (other.gameObject.tag == ("wallrunbuilding"))
        {
            PlayerSharedData.RotateOnbuilding = true;
            playerStoppedVerticalMotionBuilding.RaiseEvent();
        }
    }

    private void BuildingRotation()
    {
        Quaternion rotaiton = Quaternion.RotateTowards(PlayerSharedData.PlayerTransform.rotation, Quaternion.identity, Time.fixedDeltaTime * (PlayerContainedData.PlayerData.PlayerInformation[0].BuildingFallingRotationSpeed));
        PlayerSharedData.PlayerRigidBody.MoveRotation(rotaiton);
        if (PlayerSharedData.PlayerTransform.rotation == Quaternion.identity)
        {
            Debug.Log("WallRunBuilding is False");
            PlayerSharedData.WallRunBuilding = false;
            PlayerSharedData.RotateOnbuilding = false;
            StateMachineEventsSender.SendStateMachineEvent("ToNormalMovement");
        }
    }
}