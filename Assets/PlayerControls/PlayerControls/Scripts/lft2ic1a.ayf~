using Cinemachine;
using UnityEngine;

public class CameraMovement : CinemachineExtension
{
    [Tooltip("Accessing mian virtual cam for modyfiying certain values")]
    [SerializeField] private CinemachineVirtualCamera CinemachineVirtualCamera; //Accessing mian virtual cam for modyfiying certain values

    [Tooltip("Player shared Data contains all public variabls which are required in other scripts also")]
    [SerializeField] private PlayerSharedData PlayerSharedData;

    [SerializeField] private PlayerContainedData PlayerContainedData;
    private CinemachineFramingTransposer CinemachineFramingTransposer; // For changing values for transposer

    [SerializeField] private float offset;
    [SerializeField] private float yFollowSpeed;
    [SerializeField] private float yFollowSpeedCatchupSpeed;
    [SerializeField] private float yFollowSpeedDistIncreased;
    [SerializeField] private float inAirSpeed;
    [SerializeField] private float resettingSpeed;

    // GameEvents
    [SerializeField] private GameEvent playerHasSpawnedEvent;

    private float currentYFollowSpeed;

    private bool isInitialized;
    private bool isResetting;
    [SerializeField] private float yFollowSpeedDistDecreased;
    [SerializeField] private float offsetAbovePlayerIfminimumYDist;
    [SerializeField] private float minimumYDistToCamera;

    protected override void Awake()
    {
        base.Awake();

        SubscribeEvents();
    }

    protected override void OnEnable()
    {
        base.OnEnable();
    }

    private void SubscribeEvents()
    {
        playerHasSpawnedEvent.TheEvent.AddListener(HandlePlayerSpawned);
    }

    private void UnSubscribeEvents()
    {
        playerHasSpawnedEvent.TheEvent.RemoveListener(HandlePlayerSpawned);
    }

    //private void Update()
    //{
    //    if (CinemachineFramingTransposer != null)
    //    {
    //        float targetX = PlayerSharedData.PlayerTransform.position.x == 0 ? PlayerContainedData.CameraData.xCenterOffset : PlayerSharedData.PlayerTransform.position.x >= 0.7f ? -PlayerContainedData.CameraData.xLanesOffset : PlayerSharedData.PlayerTransform.position.x <= -0.7f ? PlayerContainedData.CameraData.xLanesOffset : CinemachineFramingTransposer.m_TrackedObjectOffset.x;
    //        CinemachineFramingTransposer.m_TrackedObjectOffset.x = Mathf.Lerp(CinemachineFramingTransposer.m_TrackedObjectOffset.x, targetX, PlayerSharedData.SidewaysSpeed);

    //    }
    //}

    private void OnDisable()
    {
        UnSubscribeEvents();
    }

    private void Start()
    {
        SubscribeEvents();
        CinemachineFramingTransposer = CinemachineVirtualCamera.GetCinemachineComponent<CinemachineFramingTransposer>();

        // WTF is this?
        MyExtensions.boostReturn = false;
    }

    public void CameraReset()
    {
        isResetting = true;
    }

    protected override void PostPipelineStageCallback(
    CinemachineVirtualCameraBase vcam,
    CinemachineCore.Stage stage, ref CameraState state, float deltaTime)
    {
        if (!isInitialized)
        {
            return;
        }

        if (isResetting)
        {
            Vector3 rawPosition = state.RawPosition;
            float y = PlayerSharedData.LastGroundedYPosition + offset;
            y = Mathf.MoveTowards(vcam.transform.position.y, y,deltaTime * resettingSpeed);
            rawPosition.y = y;
            state.RawPosition = rawPosition;

            if (transform.position.y - y <= Mathf.Epsilon)
            {
                isResetting = false;
            }

            return;
        }

        if (stage == CinemachineCore.Stage.Finalize)
        {
            float differenceY = vcam.transform.position.y - PlayerSharedData.PlayerTransform.position.y;

            if (differenceY - offset >= Mathf.Epsilon && !PlayerSharedData.IsGrounded)
            {
               // Debug.Log("FallingCamera");
                //  Debug.Log($"Falling {differenceY - offset }");
                Vector3 rawPosition = state.RawPosition;
                float y = PlayerSharedData.PlayerTransform.position.y + offset;

                y = Mathf.MoveTowards(vcam.transform.position.y, y, deltaTime * yFollowSpeedDistIncreased * Mathf.Pow(differenceY, 2)); //* PlayerSharedData.ForwardSpeed
                rawPosition.y = y;

                state.RawPosition = rawPosition;

                currentYFollowSpeed = 0;
            }
            else
            {
                //   Debug.Log("IsGroundedCamera");

                Vector3 rawPosition = state.RawPosition;

                float y = PlayerSharedData.LastGroundedYPosition + offset;
                float speed;
            
                if ( y < PlayerSharedData.PlayerTransform.position.y || differenceY <= minimumYDistToCamera )
                {
                 //   Debug.Log("OffsettingCamera");
                    y = PlayerSharedData.PlayerTransform.position.y + offsetAbovePlayerIfminimumYDist;

                    //* (1f / Mathf.Pow(differenceY, 4));
                    speed = deltaTime * yFollowSpeedDistDecreased * (Mathf.Clamp01((Mathf.Pow(differenceY, 4) * 10f))); //TimeScale

                    Debug.Log("difference " + differenceY);

                    //Debug.Log("Speed " + speed);

                    currentYFollowSpeed = 0;
                }
                else
                {
                   // Debug.Log("GroundedCamera");
                    currentYFollowSpeed += yFollowSpeedCatchupSpeed * deltaTime * PlayerSharedData.ForwardSpeed;
                    currentYFollowSpeed = Mathf.Clamp(currentYFollowSpeed, 0, yFollowSpeed);
                    speed = deltaTime * currentYFollowSpeed * PlayerSharedData.ForwardSpeed;
                }

                y = Mathf.MoveTowards(vcam.transform.position.y, y, speed);

                rawPosition.y = y;

                state.RawPosition = rawPosition;
            }

            //if (!PlayerSharedData.IsGrounded)
            //{
            //    float cur = currentYFollowSpeed;
            //    currentYFollowSpeed = Mathf.Clamp(currentYFollowSpeed/1.2f, 0, cur);
            //}
        }
    }

    private void HandlePlayerSpawned(GameEvent theEvent)
    {
        isInitialized = true;
    }
}