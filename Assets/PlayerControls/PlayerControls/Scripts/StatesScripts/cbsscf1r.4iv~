using FSM;
using UnityEngine;

[CreateAssetMenu(fileName = "PlayerThurstState", menuName = "ScriptableObjects/PlayerThurstState")]
public class PlayerThurstState : StateBase
{
    [SerializeField] private GameEvent playerHasEndedPogo;
    public PlayerSharedData PlayerSharedData;
    public PlayerContainedData PlayerContainedData;
    private float nextJumpTimer; //calculating time for next time jump .... if swiped in air timer will start and if timer is greater than 0 at landing it will jump again

    private Vector3 jumpStartPos = Vector3.zero; //getting start pos of obj so that it can move on parabola
    private Vector3 jumpEndPos = Vector3.zero; //getting end pos of obj so that it can move on parabola
    private float elapsedTime;
    private float jumpTime;
    private float Pos; //calculating diiference between my transform and jump vector and adding in to pos ehich is added in upward pos
    private bool fallingFromPogo;

    private void SubsribeInputEvents()
    {
        PlayerContainedData.InputChannel.SwipeRightOccured.AddListener(SwipedRight);
        PlayerContainedData.InputChannel.SwipeLeftOccured.AddListener(SwipedLeft);
        //     PlayerContainedData.InputChannel.SwipeDownOccured.AddListener(SwipedDown);
        PlayerContainedData.InputChannel.SwipeUpOccured.AddListener(swipeup);
    }

    /// <summary>
    ///unsubscribing all events that can occur during this state
    /// </summary>
    public void UnSubsribeInputEvents()
    {
        PlayerContainedData.InputChannel.SwipeRightOccured.RemoveListener(SwipedRight);
        PlayerContainedData.InputChannel.SwipeLeftOccured.RemoveListener(SwipedLeft);
        //    PlayerContainedData.InputChannel.SwipeDownOccured.AddListener(SwipedDown);
        PlayerContainedData.InputChannel.SwipeUpOccured.RemoveListener(swipeup);
    }

    private void SwipedRight()
    {
        PlayerContainedData.PlayerBasicMovementShared.change_lane(1);
    }

    private void SwipedLeft()
    {
        PlayerContainedData.PlayerBasicMovementShared.change_lane(-1);
    }

    private void SwipedDown()
    {
        PlayerSharedData.InAir = false;
        StateMachineEventsSender.SendStateMachineEvent("ToJumpCancel");
    }

    //onenter is like start wich will be called once when this state starts
    public override void OnEnter()
    {
        base.OnEnter();
        UnSubsribeInputEvents();
        SubsribeInputEvents();
        cancelJump();
        startJump();
        nextJumpTimer = 0;
        fallingFromPogo = false;
        Pos = 0;
    }

    //this is called when jump restarts

    //onexit will be called once when state exits
    public override void OnExit()
    {
        base.OnExit();
        UnSubsribeInputEvents();
    }

    //onlogic basically works as update , all work related to update will be done in this method
    public override void OnLogic()
    {
        nextJumpTimer -= Time.deltaTime;
        base.OnLogic();
    }

    //onfixlogic basically works as fixupdate , all work related to fixupdate will be done in this method
    public override void OnFixedLogic()
    {
        base.OnFixedLogic();
        //if (PlayerSharedData.IsDash)
        //{
        //    StateMachineEventsSender.SendStateMachineEvent("ToNormalMovement");
        //    return;
        //}
        PlayerContainedData.PlayerBasicMovementShared.movement();

        if (!PlayerSharedData.IsDash)
            Pos = jump().y - PlayerSharedData.PlayerRigidBody.position.y;

        if (!PlayerSharedData.IsDash)
            PlayerContainedData.PlayerData.PlayerInformation[0].UpwardPos = PlayerSharedData.PlayerRigidBody.position.y + Pos;

        if (!PlayerSharedData.IsGrounded)
            PlayerSharedData.InAir = true;
    }

    private float height;

    //start jump is called when jump start
    private void startJump()
    {
        jumpStartPos = PlayerSharedData.PlayerTransform.position;
        jumpEndPos = new Vector3(PlayerSharedData.PlayerTransform.position.x, PlayerContainedData.PlayerData.PlayerInformation[0].PlayerStartinPosition.y, PlayerSharedData.PlayerTransform.position.z + PlayerContainedData.PlayerData.PlayerInformation[0].ThurstJumpLength);
        PlayerContainedData.AnimationChannel.Jump("jumpspeed", PlayerContainedData.PlayerData.PlayerInformation[0].ThurstDuration);
        height = PlayerContainedData.PlayerData.PlayerInformation[0].jump_height + 10;
    }

    //will return jump vector and thorugh that vector we would move obj to y and z value.
    private Vector3 jump()
    {
        //        Debug.Log(jump().y);

        float increaseAmount = !fallingFromPogo ? 1.2f : 1.5f;

        jumpTime = Mathf.Clamp01(MyExtensions.elapse_time(ref elapsedTime, PlayerContainedData.PlayerData.PlayerInformation[0].ThurstDuration, increaseAmount));

        if (PlayerSharedData.IsGrounded && PlayerSharedData.InAir)
        {
            Debug.Log("nextJumpTimer" + nextJumpTimer);
            PlayerSharedData.InAir = false;
            if (nextJumpTimer > 0)
                StateMachineEventsSender.SendStateMachineEvent("ToJump");
            else
                StateMachineEventsSender.SendStateMachineEvent("ToNormalMovement");
            elapsedTime = 0;
        }

        Vector3 my = MathParabola.Parabola(jumpStartPos, jumpEndPos, PlayerContainedData.PlayerData.PlayerInformation[0].ThurstJumpHeight, jumpTime);

        if (jumpTime >= .5f && !fallingFromPogo)
        {
            fallingFromPogo = true;
            playerHasEndedPogo.RaiseEvent();
        }

        return my;
    }

    private void swipeup()
    {
        nextJumpTimer = PlayerContainedData.PlayerData.PlayerInformation[0].NextJumpTimer;
    }

    private void cancelJump()
    {
        elapsedTime = 0;
        jumpStartPos = Vector3.zero;
        jumpEndPos = Vector3.zero;
        jumpTime = 0;
        PlayerSharedData.InAir = false;
    }
}