using FSM;
using UnityEngine;

[CreateAssetMenu(fileName = "PlayerAeroplaneState", menuName = "ScriptableObjects/PlayerAeroplaneState")]
public class PlayerAeroplaneState : StateBase
{
    public PlayerSharedData PlayerSharedData;
    public PlayerContainedData PlayerContainedData;

    [SerializeField] private SpeedHandler speedHandler;

    private Vector3 jumpStartPos = Vector3.zero; //getting start pos of obj so that it can move on parabola
    private Vector3 jumpEndPos = Vector3.zero; //getting end pos of obj so that it can move on parabola
    private float elapsedTime;
    private float jumpTime;
    private float Pos; //calculating diiference between my transform and jump vector and adding in to pos ehich is added in upward pos

    private float stateElapsedTime;
    [SerializeField] private float lifeTime = 1f;

    private void SubsribeInputEvents()
    {
        PlayerContainedData.InputChannel.SwipeRightOccured.AddListener(SwipedRight);
        PlayerContainedData.InputChannel.SwipeLeftOccured.AddListener(SwipedLeft);
    }

    /// <summary>
    ///unsubscribing all events that can occur during this state
    /// </summary>
    public void UnSubsribeInputEvents()
    {
        PlayerContainedData.InputChannel.SwipeRightOccured.RemoveListener(SwipedRight);
        PlayerContainedData.InputChannel.SwipeLeftOccured.RemoveListener(SwipedLeft);
    }

    private void SwipedRight()
    {
        PlayerContainedData.PlayerBasicMovementShared.change_lane(1);
    }

    private void SwipedLeft()
    {
        PlayerContainedData.PlayerBasicMovementShared.change_lane(-1);
    }

    //onenter is like start wich will be called once when this state starts
    public override void OnEnter()
    {
     
        base.OnEnter();
        UnSubsribeInputEvents();
        SubsribeInputEvents();
        cancelJump();
        startJump();
        Pos = 0;


        PlayerContainedData.PlayerBoostState.StopDash();
        speedHandler.ChangeGameTimeScaleInTime(PlayerContainedData.PlayerData.PlayerInformation[0].FlyingMaxSpeed, PlayerContainedData.PlayerData.PlayerInformation[0].TimeToReachFlyingMaxSpeed,true,true);
        PlayerSharedData.CarSkeleton.WingsTransform.SetActive(true);
    }

    //this is called when jump restarts

    //onexit will be called once when state exits
    public override void OnExit()
    {
        PlayerSharedData.CarSkeleton.WingsTransform.SetActive(false);
        base.OnExit();
        UnSubsribeInputEvents();

        speedHandler.RemoveOverrideGameTimeScaleMode(PlayerContainedData.PlayerData.PlayerInformation[0].TimeToReachFlyingMaxSpeed);

        PlayerSharedData.PlayerAnimator.enabled = true;
    }

    //onlogic basically works as update , all work related to update will be done in this method
    public override void OnLogic()
    {
        base.OnLogic();
        stateElapsedTime += Time.deltaTime;

        if (stateElapsedTime > lifeTime)
        {
            PlayerSharedData.InAir = false;
            StateMachineEventsSender.SendStateMachineEvent("ToNormalMovement");
            elapsedTime = 0;
        }
    }

    //onfixlogic basically works as fixupdate , all work related to fixupdate will be done in this method
    public override void OnFixedLogic()
    {
        base.OnFixedLogic();

        PlayerContainedData.PlayerBasicMovementShared.movement();

        if (!PlayerSharedData.IsDash)
            Pos = jump().y - PlayerSharedData.PlayerRigidBody.position.y;

        if (!PlayerSharedData.IsDash)
            PlayerContainedData.PlayerData.PlayerInformation[0].UpwardPos = PlayerSharedData.PlayerRigidBody.position.y + Pos;

        if (!PlayerSharedData.IsGrounded)
            PlayerSharedData.InAir = true;
    }

    //start jump is called when jump start
    private void startJump()
    {
        jumpStartPos = PlayerSharedData.PlayerTransform.position;
        jumpEndPos = new Vector3(PlayerSharedData.PlayerTransform.position.x, PlayerContainedData.PlayerData.PlayerInformation[0].PlayerStartinPosition.y, PlayerSharedData.PlayerTransform.position.z + PlayerContainedData.PlayerData.PlayerInformation[0].jump_length);
      //  PlayerContainedData.AnimationChannel.Jump("jumpspeed", PlayerSharedData.JumpDuration);

        PlayerSharedData.PlayerAnimator.Play("Normal");
        PlayerSharedData.PlayerAnimator.enabled = false;
    }

    //will return jump vector and thorugh that vector we would move obj to y and z value.
    private Vector3 jump()
    {
        //        Debug.Log(jump().y);

        jumpTime = Mathf.Clamp01(MyExtensions.elapse_time(ref elapsedTime, PlayerContainedData.PlayerData.PlayerInformation[0].TimeToReachFlyingTopHeight));

        jumpTime = Mathf.Clamp(jumpTime, 0, 0.5f);
        Vector3 my = MathParabola.Parabola(jumpStartPos, jumpEndPos, PlayerContainedData.PlayerData.PlayerInformation[0].FlyingHeight, jumpTime);

        return my;
    }

    private void cancelJump()
    {
        stateElapsedTime = 0;
        elapsedTime = 0;
        jumpStartPos = Vector3.zero;
        jumpEndPos = Vector3.zero;
        jumpTime = 0;
        PlayerSharedData.InAir = false;
    }
}